name: Build & Release AARs (OpenSSL-aligned)

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      OPENSSL_VERSION:
        description: 'OpenSSL version to build (required for manual dispatch)'
        required: false
        default: ''
      SKIP_OPENSSL_BUILD:
        description: 'Skip building OpenSSL (0 or 1)'
        required: false
        default: '0'
      SHIP_OPENSSL_SOURCE:
        description: 'Copy OpenSSL source to package folder (0 or 1)'
        required: false
        default: '1'
      SHIP_SOURCE_TO_AAR:
        description: 'Include OpenSSL source inside AAR assets (0 or 1)'
        required: false
        default: '0'
      INCLUDE_STATIC:
        description: 'Include .a static libs in package (0 or 1)'
        required: false
        default: '1'
      INCLUDE_SHARED:
        description: 'Include .so shared libs in package (0 or 1)'
        required: false
        default: '1'
      NDK:
        description: 'Android NDK version to install'
        required: false
        default: '21.4.7075529'

# Ensure the workflow has the necessary token permissions to create releases
# and publish packages. These can be tightened as needed.
permissions:
  contents: write
  packages: write

jobs:
  prepare:
    runs-on: ubuntu-latest
    outputs:
      OPENSSL_VERSION: ${{ steps.set.outputs.OPENSSL_VERSION }}
      NDK: ${{ steps.set.outputs.NDK }}
      SKIP_OPENSSL_BUILD: ${{ steps.set.outputs.SKIP_OPENSSL_BUILD }}
      SHIP_OPENSSL_SOURCE: ${{ steps.set.outputs.SHIP_OPENSSL_SOURCE }}
      SHIP_SOURCE_TO_AAR: ${{ steps.set.outputs.SHIP_SOURCE_TO_AAR }}
      INCLUDE_STATIC: ${{ steps.set.outputs.INCLUDE_STATIC }}
      INCLUDE_SHARED: ${{ steps.set.outputs.INCLUDE_SHARED }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Derive inputs
        id: set
        run: |
          set -euo pipefail
          if [ "${{ github.event_name }}" = "push" ]; then
            TAG=${{ github.ref_name }}
            OPENSSL_VERSION=${TAG#v}
          else
            OPENSSL_VERSION="${{ github.event.inputs.OPENSSL_VERSION }}"
          fi
          if [ -z "$OPENSSL_VERSION" ]; then
            echo "OPENSSL_VERSION must be provided (tag or workflow input)"
            exit 1
          fi
          # Ensure NDK has a sensible default when not provided via workflow inputs
          NDK_INPUT="${{ github.event.inputs.NDK }}"
          if [ -z "$NDK_INPUT" ]; then
            NDK_INPUT="21.4.7075529"
          fi
          # Use the Actions environment file to set step outputs (set-output is deprecated)
          echo "OPENSSL_VERSION=$OPENSSL_VERSION" >> $GITHUB_OUTPUT
          echo "NDK=$NDK_INPUT" >> $GITHUB_OUTPUT
          echo "SKIP_OPENSSL_BUILD=${{ github.event.inputs.SKIP_OPENSSL_BUILD }}" >> $GITHUB_OUTPUT
          echo "SHIP_OPENSSL_SOURCE=${{ github.event.inputs.SHIP_OPENSSL_SOURCE }}" >> $GITHUB_OUTPUT
          echo "SHIP_SOURCE_TO_AAR=${{ github.event.inputs.SHIP_SOURCE_TO_AAR }}" >> $GITHUB_OUTPUT
          echo "INCLUDE_STATIC=${{ github.event.inputs.INCLUDE_STATIC }}" >> $GITHUB_OUTPUT
          echo "INCLUDE_SHARED=${{ github.event.inputs.INCLUDE_SHARED }}" >> $GITHUB_OUTPUT

  build-openssl:
    needs: prepare
    runs-on: ubuntu-latest
    strategy:
      matrix:
        abi: [armeabi-v7a, arm64-v8a, x86, x86_64]
        build_type: [release, debug]
    # Do not set runner.temp in YAML expressions (not supported). We'll use
    # the runtime $RUNNER_TEMP variable inside the shell steps instead.
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Setup Java 17
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: '17'
      - name: Install Android SDK & NDK (sdkmanager)
        run: |
          set -euo pipefail
          sudo apt-get update
          sudo apt-get install -y unzip curl
          ANDROID_SDK_ROOT="$RUNNER_TEMP/android-sdk"
          mkdir -p "$ANDROID_SDK_ROOT/cmdline-tools"
          TMP_ZIP="/tmp/cmdline-tools.zip"
          curl -sSL https://dl.google.com/android/repository/commandlinetools-linux-9477386_latest.zip -o "$TMP_ZIP"
          unzip -q "$TMP_ZIP" -d "$ANDROID_SDK_ROOT/cmdline-tools"
          export PATH="$ANDROID_SDK_ROOT/cmdline-tools/cmdline-tools/bin:$PATH"
          yes | sdkmanager --sdk_root="$ANDROID_SDK_ROOT" --licenses || true
          sdkmanager --sdk_root="$ANDROID_SDK_ROOT" "platform-tools" "platforms;android-33" "ndk;${{ needs.prepare.outputs.NDK }}"
          echo "ANDROID_NDK_HOME=$ANDROID_SDK_ROOT/ndk/${{ needs.prepare.outputs.NDK }}" >> $GITHUB_ENV
          echo "ANDROID_SDK_ROOT=$ANDROID_SDK_ROOT" >> $GITHUB_ENV
          echo "ANDROID_HOME=$ANDROID_SDK_ROOT" >> $GITHUB_ENV
      - name: Build OpenSSL for matrix entry
        env:
          OPENSSL_VERSION: ${{ needs.prepare.outputs.OPENSSL_VERSION }}
          ABI: ${{ matrix.abi }}
          BUILD_TYPE: ${{ matrix.build_type }}
        run: |
          set -euo pipefail
          echo "Building for ABI=$ABI BUILD_TYPE=$BUILD_TYPE"
          # Run the build script restricted to the single ABI/build type
          ABIS=("$ABI")
          BUILD_TYPES=("$BUILD_TYPE")
          chmod +x ./scripts/build-openssl.sh
          ./scripts/build-openssl.sh
      - name: Upload OpenSSL artifact
        uses: actions/upload-artifact@v4
        with:
          name: openssl-${{ needs.prepare.outputs.OPENSSL_VERSION }}-${{ matrix.abi }}-${{ matrix.build_type }}
          path: third_party/openssl/${{ needs.prepare.outputs.OPENSSL_VERSION }}/${{ matrix.abi }}/${{ matrix.build_type }}

  package:
    needs: build-openssl
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Download artifacts
        uses: actions/download-artifact@v4
        with:
          path: ./artifacts
      - name: Show downloaded artifacts
        run: ls -R artifacts || true
      - name: Setup Java (for Gradle)
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: '17'
      - name: Prepare SDK (sdkmanager)
        run: |
          set -euo pipefail
          sudo apt-get update
          sudo apt-get install -y unzip curl
          ANDROID_SDK_ROOT="$HOME/android-sdk"
          mkdir -p "$ANDROID_SDK_ROOT/cmdline-tools"
          TMP_ZIP="/tmp/cmdline-tools.zip"
          curl -sSL https://dl.google.com/android/repository/commandlinetools-linux-9477386_latest.zip -o "$TMP_ZIP"
          unzip -q "$TMP_ZIP" -d "$ANDROID_SDK_ROOT/cmdline-tools"
          export PATH="$ANDROID_SDK_ROOT/cmdline-tools/cmdline-tools/bin:$PATH"
          yes | sdkmanager --sdk_root="$ANDROID_SDK_ROOT" --licenses || true
          sdkmanager --sdk_root="$ANDROID_SDK_ROOT" "platform-tools" "platforms;android-33"
          echo "ANDROID_SDK_ROOT=$ANDROID_SDK_ROOT" >> $GITHUB_ENV
          echo "ANDROID_HOME=$ANDROID_SDK_ROOT" >> $GITHUB_ENV
      - name: Restore built outputs into third_party
        run: |
          set -euo pipefail
          set -x
          mkdir -p third_party/openssl/${{ needs.prepare.outputs.OPENSSL_VERSION }}
          for d in artifacts/*; do
            [ -d "$d" ] || continue
            base=$(basename "$d")
            # Expect artifact names like: openssl-<version>-<abi>-<build_type>
            if [[ "$base" =~ ^openssl-([0-9]+\.[0-9]+\.[0-9]+)-([^/]+)-([^/]+)$ ]]; then
              ver="${BASH_REMATCH[1]}"
              abi="${BASH_REMATCH[2]}"
              btype="${BASH_REMATCH[3]}"
              dest="third_party/openssl/$ver/$abi/$btype"
              echo "Restoring artifact $base -> $dest"
              mkdir -p "$dest"
              cp -a "$d"/* "$dest/" || true
            else
              echo "Unknown artifact layout for $base; copying contents into third_party/openssl/"
              cp -a "$d"/* third_party/openssl/ || true
            fi
          done
          echo "Restored third_party tree:" && ls -R third_party || true
      - name: Detect restored OpenSSL outputs and skip build if present
        run: |
          set -euo pipefail
          if [ -d "third_party/openssl/${{ needs.prepare.outputs.OPENSSL_VERSION }}" ]; then
            echo "Found restored OpenSSL outputs; setting SKIP_OPENSSL_BUILD=1"
            echo "SKIP_OPENSSL_BUILD=1" >> $GITHUB_ENV
          else
            echo "No restored OpenSSL outputs found; packaging step will build OpenSSL"
          fi
      - name: Run packaging script
        env:
          OPENSSL_VERSION: ${{ needs.prepare.outputs.OPENSSL_VERSION }}
          SHIP_OPENSSL_SOURCE: ${{ needs.prepare.outputs.SHIP_OPENSSL_SOURCE }}
          SHIP_SOURCE_TO_AAR: ${{ needs.prepare.outputs.SHIP_SOURCE_TO_AAR }}
          INCLUDE_STATIC: ${{ needs.prepare.outputs.INCLUDE_STATIC }}
          INCLUDE_SHARED: ${{ needs.prepare.outputs.INCLUDE_SHARED }}
        run: |
          set -euo pipefail
          # Respect SKIP_OPENSSL_BUILD set earlier by the restore detection step (or workflow input)
          : "SKIP_OPENSSL_BUILD=${SKIP_OPENSSL_BUILD:-${{ needs.prepare.outputs.SKIP_OPENSSL_BUILD }}}"
          echo "SKIP_OPENSSL_BUILD=$SKIP_OPENSSL_BUILD"
          chmod +x ./scripts/package-aar.sh
          ./scripts/package-aar.sh
      - name: Upload package artifacts to GitHub Release (create if needed)
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REPO: ${{ github.repository }}
          TAG: ${{ github.ref_name }}
        run: |
          set -euo pipefail
          API="https://api.github.com/repos/$REPO"
          UPLOADS="https://uploads.github.com/repos/$REPO/releases"

          echo "Looking up release for tag: $TAG"
          http_code=$(curl -s -o /tmp/release.json -w "%{http_code}" -H "Authorization: token $GITHUB_TOKEN" "$API/releases/tags/$TAG")
          if [ "$http_code" = "200" ]; then
            # parse id from JSON without relying on python/jq
            RELEASE_ID=$(grep -o '"id"[[:space:]]*:[[:space:]]*[0-9]\+' /tmp/release.json | head -n1 | sed 's/[^0-9]*//g' || true)
            echo "Found existing release id: $RELEASE_ID"
          else
            echo "Release not found (http $http_code) â€” creating new release $TAG"
            http_code=$(curl -s -o /tmp/create.json -w "%{http_code}" -X POST -H "Authorization: token $GITHUB_TOKEN" -H "Content-Type: application/json" \
              -d "{\"tag_name\": \"$TAG\", \"name\": \"$TAG\", \"body\": \"Release created by CI\", \"draft\": false, \"prerelease\": false}" \
              "$API/releases")
            if [ "$http_code" != "201" ]; then
              echo "Failed to create release (http $http_code)" >&2
              cat /tmp/create.json >&2 || true
              exit 1
            fi
            RELEASE_ID=$(grep -o '"id"[[:space:]]*:[[:space:]]*[0-9]\+' /tmp/create.json | head -n1 | sed 's/[^0-9]*//g' || true)
            echo "Created release id: $RELEASE_ID"
          fi

          # Create tar.gz and zip archives of the package folder for npm consumption
          if [ ! -d native-sea-openssl-package ]; then
            echo "No package folder found to upload: native-sea-openssl-package" >&2
            exit 1
          fi
          echo "Creating archives native-sea-openssl.tar.gz and native-sea-openssl.zip"
          rm -f native-sea-openssl.tar.gz native-sea-openssl.zip || true
          (cd native-sea-openssl-package && tar -czf ../native-sea-openssl.tar.gz .)
          (cd native-sea-openssl-package && zip -r ../native-sea-openssl.zip .) >/dev/null

          for f in native-sea-openssl.tar.gz native-sea-openssl.zip; do
            if [ ! -f "$f" ]; then
              echo "Expected archive missing: $f" >&2
              continue
            fi
            name=$(basename "$f")
            echo "Uploading $f as $name"
            # choose proper content-type for archives
            content_type="application/octet-stream"
            if [[ "$f" == *.tar.gz ]]; then content_type="application/gzip"; fi
            if [[ "$f" == *.zip ]]; then content_type="application/zip"; fi
            curl -s -X POST -H "Authorization: token $GITHUB_TOKEN" -H "Content-Type: $content_type" \
              --data-binary @"$f" "$UPLOADS/$RELEASE_ID/assets?name=$name" || true
          done
